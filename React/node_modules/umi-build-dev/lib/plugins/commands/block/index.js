"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _chalk = _interopRequireDefault(require("chalk"));

var _fs = require("fs");

var _path = require("path");

var _ora = _interopRequireDefault(require("ora"));

var _lodash = require("lodash");

var _getnpmregistry = _interopRequireDefault(require("getnpmregistry"));

var _clipboardy = _interopRequireDefault(require("clipboardy"));

var _download = require("./download");

var _writeNewRoute = _interopRequireDefault(require("../../../utils/writeNewRoute"));

var _getBlockGenerator = require("./getBlockGenerator");

var _appendBlockToContainer = _interopRequireDefault(require("./appendBlockToContainer"));

var _util = require("./util");

var _tsTojs = _interopRequireDefault(require("./tsTojs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default = api => {
  const log = api.log,
        paths = api.paths,
        debug = api.debug,
        applyPlugins = api.applyPlugins,
        config = api.config;
  const blockConfig = config.block || {};
  debug(`blockConfig ${blockConfig}`);

  function block() {
    return _block.apply(this, arguments);
  }

  function _block() {
    _block = _asyncToGenerator(function* (args = {}) {
      let retCtx;

      switch (args._[0]) {
        case 'add':
          retCtx = yield add(args);
          break;

        case 'list':
          yield (0, _util.getDefaultBlockList)(args);
          break;

        default:
          throw new Error(`Please run ${_chalk.default.cyan.underline('umi help block')} to checkout the usage`);
      }

      return retCtx; // return for test
    });
    return _block.apply(this, arguments);
  }

  function getCtx(url, args = {}) {
    debug(`get url ${url}`);
    const ctx = (0, _download.getParsedData)(url, blockConfig);

    if (!ctx.isLocal) {
      const blocksTempPath = (0, _download.makeSureMaterialsTempPathExist)(args.dryRun);
      const templateTmpDirPath = (0, _path.join)(blocksTempPath, ctx.id);
      (0, _lodash.merge)(ctx, {
        sourcePath: (0, _path.join)(templateTmpDirPath, ctx.path),
        branch: args.branch || ctx.branch,
        templateTmpDirPath,
        blocksTempPath,
        repoExists: (0, _fs.existsSync)(templateTmpDirPath)
      });
    } else {
      (0, _lodash.merge)(ctx, {
        templateTmpDirPath: (0, _path.dirname)(url)
      });
    }

    return ctx;
  }

  function add() {
    return _add.apply(this, arguments);
  }

  function _add() {
    _add = _asyncToGenerator(function* (args = {}) {
      const spinner = (0, _ora.default)(); // 1. parse url and args

      spinner.start('😁 Parse url and args');
      const url = args._[1];
      (0, _assert.default)(url, `run ${_chalk.default.cyan.underline('umi help block')} to checkout the usage`);
      const useYarn = (0, _fs.existsSync)((0, _path.join)(paths.cwd, 'yarn.lock'));
      const defaultNpmClient = blockConfig.npmClient || (useYarn ? 'yarn' : 'npm');
      debug(`defaultNpmClient: ${defaultNpmClient}`);
      debug(`args: ${JSON.stringify(args)}`); // get faster registry url

      const registryUrl = yield (0, _getnpmregistry.default)();
      const path = args.path,
            _args$npmClient = args.npmClient,
            npmClient = _args$npmClient === void 0 ? defaultNpmClient : _args$npmClient,
            dryRun = args.dryRun,
            skipDependencies = args.skipDependencies,
            skipModifyRoutes = args.skipModifyRoutes,
            isPage = args.page,
            isLayout = args.layout,
            _args$registry = args.registry,
            registry = _args$registry === void 0 ? registryUrl : _args$registry,
            js = args.js;
      const ctx = getCtx(url, args);
      spinner.succeed(); // 2. clone git repo

      if (!ctx.isLocal && !ctx.repoExists) {
        yield (0, _util.gitClone)(ctx, spinner);
      } // 3. update git repo


      if (!ctx.isLocal && ctx.repoExists) {
        yield (0, _util.gitUpdate)(ctx, spinner);
      } // make sure sourcePath exists


      (0, _assert.default)((0, _fs.existsSync)(ctx.sourcePath), `${ctx.sourcePath} don't exists`); // get block's package.json

      const pkgPath = (0, _path.join)(ctx.sourcePath, 'package.json');

      if (!(0, _fs.existsSync)(pkgPath)) {
        throw new Error(`not find package.json in ${this.sourcePath}`);
      } else {
        // eslint-disable-next-line
        ctx.pkg = require(pkgPath);
      } // setup route path


      if (!path) {
        const blockName = (0, _getBlockGenerator.getNameFromPkg)(ctx.pkg);

        if (!blockName) {
          return log.error("not find name in block's package.json");
        }

        ctx.routePath = `/${blockName}`;
        log.info(`Not find --path, use block name '${ctx.routePath}' as the target path.`);
      } else {
        ctx.routePath = path;
      } // fix demo => /demo


      if (!/^\//.test(ctx.routePath)) {
        ctx.routePath = `/${ctx.routePath}`;
      } // 4. install additional dependencies
      // check dependencies conflict and install dependencies


      if (skipDependencies) {
        debug('skip dependencies');
      } else {
        // install
        spinner.start(`📦 install dependencies package`);
        yield (0, _util.installDependencies)({
          npmClient,
          registry,
          applyPlugins,
          paths,
          debug,
          dryRun,
          spinner
        }, ctx);
        spinner.stopAndPersist();
      } // 5. run generator


      spinner.start(`🔥 Generate files`);
      spinner.stopAndPersist();

      const BlockGenerator = require('./getBlockGenerator').default(api);

      let isPageBlock = ctx.pkg.blockConfig && ctx.pkg.blockConfig.specVersion === '0.1';

      if (isPage !== undefined) {
        // when user use `umi block add --page`
        isPageBlock = isPage;
      }

      debug(`isPageBlock: ${isPageBlock}`);
      const generator = new BlockGenerator(args._.slice(2), {
        sourcePath: ctx.sourcePath,
        path: ctx.routePath,
        blockName: (0, _getBlockGenerator.getNameFromPkg)(ctx.pkg),
        isPageBlock,
        dryRun,
        env: {
          cwd: api.cwd
        },
        resolved: __dirname
      });

      try {
        yield generator.run();
      } catch (e) {
        spinner.fail();
        throw new Error(e);
      } // write dependencies


      if (ctx.pkg.blockConfig && ctx.pkg.blockConfig.dependencies) {
        const subBlocks = ctx.pkg.blockConfig.dependencies;

        try {
          yield Promise.all(subBlocks.map(block => {
            const subBlockPath = (0, _path.join)(ctx.templateTmpDirPath, block);
            debug(`subBlockPath: ${subBlockPath}`);
            return new BlockGenerator(args._.slice(2), {
              sourcePath: subBlockPath,
              path: isPageBlock ? generator.path : (0, _path.join)(generator.path, generator.blockFolderName),
              // eslint-disable-next-line
              blockName: (0, _getBlockGenerator.getNameFromPkg)(require((0, _path.join)(subBlockPath, 'package.json'))),
              isPageBlock: false,
              dryRun,
              env: {
                cwd: api.cwd
              },
              resolved: __dirname
            }).run();
          }));
        } catch (e) {
          spinner.fail();
          throw new Error(e);
        }
      }

      spinner.succeed(); // 调用 sylvanas 转化 ts

      if (js) {
        spinner.start('🤔 TypeScript to JavaScript');
        (0, _tsTojs.default)(generator.blockFolderPath);
        spinner.succeed();
      } // 6. write routes


      if (generator.needCreateNewRoute && api.config.routes && !skipModifyRoutes) {
        spinner.start(`🧐  Write route ${generator.path} to ${api.service.userConfig.file}`); // 当前 _modifyBlockNewRouteConfig 只支持配置式路由
        // 未来可以做下自动写入注释配置，支持约定式路由

        const newRouteConfig = applyPlugins('_modifyBlockNewRouteConfig', {
          initialValue: _objectSpread({
            path: generator.path.toLowerCase(),
            component: `.${generator.path}`
          }, isLayout ? {
            routes: []
          } : {})
        });

        try {
          if (!dryRun) {
            (0, _writeNewRoute.default)(newRouteConfig, api.service.userConfig.file, paths.absSrcPath);
          }
        } catch (e) {
          spinner.fail();
          throw new Error(e);
        }

        spinner.succeed();
      } // 6. import block to container


      if (!generator.isPageBlock) {
        spinner.start(`Write block component ${generator.blockFolderName} import to ${generator.entryPath}`);

        try {
          (0, _appendBlockToContainer.default)({
            entryPath: generator.entryPath,
            blockFolderName: generator.blockFolderName,
            dryRun
          });
        } catch (e) {
          spinner.fail();
          throw new Error(e);
        }

        spinner.succeed();
      } // Final: show success message


      const viewUrl = `http://localhost:${process.env.PORT || '8000'}${generator.path.toLowerCase()}`;

      try {
        _clipboardy.default.writeSync(viewUrl);

        log.success(`probable url ${_chalk.default.cyan(viewUrl)} ${_chalk.default.dim('(copied to clipboard)')} for view the block.`);
      } catch (e) {
        log.success(`probable url ${_chalk.default.cyan(viewUrl)} for view the block.`);
        log.error('copy to clipboard failed');
      }

      return {
        generator,
        ctx
      }; // return ctx and generator for test
    });
    return _add.apply(this, arguments);
  }

  const details = `

Commands:

  ${_chalk.default.cyan(`add `)}     add a block to your project
  ${_chalk.default.cyan(`list`)}     list all blocks

Options for the ${_chalk.default.cyan(`add`)} command:

  ${_chalk.default.green(`--path              `)} the route path, default the name in package.json
  ${_chalk.default.green(`--branch            `)} git branch
  ${_chalk.default.green(`--npm-client        `)} the npm client, default npm or yarn (if has yarn.lock)
  ${_chalk.default.green(`--skip-dependencies `)} don't install dependencies
  ${_chalk.default.green(`--skip-modify-routes`)} don't modify the routes
  ${_chalk.default.green(`--dry-run           `)} for test, don't install dependencies and download
  ${_chalk.default.green(`--page              `)} add the block to a independent directory as a page
  ${_chalk.default.green(`--layout            `)} add as a layout block (add route with empty children)
  ${_chalk.default.green(`--js            `)} If the block is typescript, convert to js
  ${_chalk.default.green(`--registry            `)} set up npm installation using the registry

Examples:

  ${_chalk.default.gray(`# Add block`)}
  umi block add demo
  umi block add ant-design-pro/Monitor

  ${_chalk.default.gray(`# Add block with full url`)}
  umi block add https://github.com/umijs/umi-blocks/tree/master/demo

  ${_chalk.default.gray(`# Add block with specified route path`)}
  umi block add demo --path /foo/bar

  ${_chalk.default.gray(`# List all blocks`)}
  umi block list
  `.trim();
  api.registerCommand('block', {
    description: 'block related commands, e.g. add, list',
    usage: `umi block <command>`,
    details
  }, args => {
    // reture only for test
    return block(args).catch(e => {
      log.error(e);
    });
  });

  api._registerConfig(() => {
    return () => {
      return {
        name: 'block',

        validate(val) {
          (0, _assert.default)((0, _lodash.isPlainObject)(val), `Configure item block should be Plain Object, but got ${val}.`);
        }

      };
    };
  });
};

exports.default = _default;